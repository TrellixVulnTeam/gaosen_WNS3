{"remainingRequest":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\CodingForFun\\Vue\\gaosen\\docs\\.vuepress\\components\\Chess1.vue?vue&type=style&index=0&id=b5d5d280&scoped=true&lang=scss&","dependencies":[{"path":"D:\\CodingForFun\\Vue\\gaosen\\docs\\.vuepress\\components\\Chess1.vue","mtime":1653225976922},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\css-loader\\dist\\cjs.js","mtime":1648514419984},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1648514420974},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\postcss-loader\\src\\index.js","mtime":1648514420186},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\sass-loader\\dist\\cjs.js","mtime":1648533350822},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1648514419946},{"path":"D:\\CodingForFun\\Vue\\gaosen\\node_modules\\vue-loader\\lib\\index.js","mtime":1648514420515}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoNCi5pbnB1dC1ib3ggew0KICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWE2YWE2Ow0KICBkaXNwbGF5OiBmbGV4Ow0KICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47DQogIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogIGJvcmRlci1yYWRpdXM6IDhweDsNCiAgcGFkZGluZzogMCAwIDAgMTVweDsNCiAgb3ZlcmZsb3c6IGhpZGRlbjsNCiAgaGVpZ2h0OiA1Y2g7DQoNCg0KICBpOjpiZWZvcmUgew0KICAgIGZvbnQtc2l6ZTogMS41Y2g7DQogICAgY29sb3I6IHdoaXRlOw0KICB9DQoNCiAgaW5wdXQgew0KICAgIGJvcmRlcjogbm9uZTsNCiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94Ow0KICAgIGJhY2tncm91bmQ6IG5vbmU7DQogICAgY29sb3I6IHdoaXRlOw0KICAgIG91dGxpbmU6IG5vbmU7DQogICAgbWFyZ2luLWxlZnQ6IDVweDsNCiAgICBwYWRkaW5nOiA1cHg7DQogICAgd2lkdGg6IDEwMCU7DQogIH0NCg0KICBpbnB1dDo6cGxhY2Vob2xkZXIgew0KICAgIGNvbG9yOiB3aGl0ZTsNCiAgfQ0KDQogIGRpdiB7DQogICAgYmFja2dyb3VuZC1jb2xvcjogI2UwZTFlMjsNCiAgICBjdXJzb3I6IHBvaW50ZXI7DQogICAgY29sb3I6ICM1YTVhNWE7DQogICAgaGVpZ2h0OiAxMDAlOw0KICAgIGRpc3BsYXk6IGZsZXg7DQogICAgYWxpZ24taXRlbXM6IGNlbnRlcjsNCiAgICBwYWRkaW5nOiA1cHggMTBweDsNCiAgICB3aWR0aDogMjAlOw0KICAgIGZvbnQtd2VpZ2h0OiA2MDA7DQogICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7DQogIH0NCg0KICBkaXY6aG92ZXIgew0KICAgIGJhY2tncm91bmQtY29sb3I6ICNjYWNiY2Q7DQogIH0NCn0NCi5mMSB7DQogIG1hcmdpbjogMCA1cHg7DQogIGJvcmRlcjogbm9uZTsNCiAgYm94LXNpemluZzogYm9yZGVyLWJveDsNCiAgcGFkZGluZzogMTNweCAxMHB4Ow0KICBjb2xvcjogd2hpdGU7DQogIGJhY2tncm91bmQtY29sb3I6ICMxYTZhYTY7DQogIGJvcmRlci1yYWRpdXM6IDEwcHg7DQogIGN1cnNvcjogcG9pbnRlcjsNCiAgZm9udC13ZWlnaHQ6IDYwMDsNCn0NCi5mMTpob3ZlciB7DQogIGJhY2tncm91bmQtY29sb3I6ICMxMjYwOWI7DQp9DQouY2hlc3NCb2FyZCB7DQogIGRpc3BsYXk6IGZsZXg7DQogIGZsZXgtd3JhcDogd3JhcDsNCiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOw0KICB3aWR0aDogNjUlOw0KICBwYWRkaW5nOiAwLjJ2dzsNCiAgYm9yZGVyOiAycHggc29saWQgYmxhY2s7DQogIGJveC1zaXppbmc6IGJvcmRlci1ib3g7DQogIHBvc2l0aW9uOiByZWxhdGl2ZTsNCiAgbWFyZ2luOiBhdXRvOw0KICAubXlGb250Qm94IHsNCiAgICBmb250LWZhbWlseTogJ0xpU2h1JyxzZXJpZjsNCiAgICBwb3NpdGlvbjogYWJzb2x1dGU7DQogICAgdG9wOiA0NiU7DQogICAgbGVmdDogNTAlOw0KICAgIGRpc3BsYXk6IGZsZXg7DQogICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7DQogICAgd2lkdGg6IDEwMCU7DQogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpOw0KICAgIGZvbnQtc2l6ZTogM3Z3Ow0KICAgIGRpdiB7DQogICAgfQ0KICB9DQogIC5pbWdCb3ggew0KICAgIHdpZHRoOiAxMS4xJTsNCiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94Ow0KICAgIHBhZGRpbmc6IDAuMnZ3Ow0KICAgIC8vYm9yZGVyOiAxcHggc29saWQgYmxhY2s7DQogICAgYmFja2dyb3VuZDogdXJsKCIuLi9wdWJsaWMvaW1nL2NoZXNzL2JjLnBuZyIpOw0KICAgIGJhY2tncm91bmQtc2l6ZTogMTAwJTsNCg0KICAgIGltZyB7DQogICAgICB3aWR0aDogMTAwJTsNCiAgICAgIGN1cnNvcjogcG9pbnRlcjsNCg0KICAgIH0NCg0KICAgIDpob3ZlciB7DQogICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7DQogICAgfQ0KICB9DQoNCiAgOm50aC1jaGlsZChuKzM3KTpudGgtY2hpbGQoLW4rNTQpIHsNCiAgICAvL2JvcmRlcjogbm9uZTsNCiAgICAvL2JhY2tncm91bmQ6IG5vbmU7DQogICAgLy9iYWNrZ3JvdW5kLWltYWdlOiB1cmwoIi4uL3B1YmxpYy9pbWcvY2hlc3MvYmMtZG93bi5wbmciKTsNCiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7DQogICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsNCiAgICAvL21hcmdpbjogMTBweCAwOw0KICAgIC8vcGFkZGluZzogMDsNCiAgICAvL2Rpc3BsYXk6IGZsZXg7DQogICAgLy9qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsNCiAgICAvL2FsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAgaW1nIHsNCiAgICAgIC8vY3Vyc29yOiBkZWZhdWx0Ow0KICAgICAgLy93aWR0aDogODAlOw0KDQogICAgfQ0KICB9DQogIDpudGgtY2hpbGQobiszNyk6bnRoLWNoaWxkKC1uKzQ1KSB7DQogICAgbWFyZ2luOiAtMTBweCAwIDEwcHggMDsNCiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL3B1YmxpYy9pbWcvY2hlc3MvYmMtdXAucG5nJyk7DQogICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsNCiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7DQogIH0NCiAgOm50aC1jaGlsZChuKzQ2KTpudGgtY2hpbGQoLW4rNTQpIHsNCiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL3B1YmxpYy9pbWcvY2hlc3MvYmMtZG93bi5wbmcnKTsNCiAgICBtYXJnaW46IDEwcHggMCAtMTBweCAwOw0KICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7DQogICAgYmFja2dyb3VuZC1zaXplOiAxMDAlOw0KICB9DQp9DQoNCkBmb250LWZhY2Ugew0KICBmb250LWZhbWlseTogJ0xpU2h1JzsNCiAgLy9zcmM6IHVybCgnWW91cldlYkZvbnROYW1lLmVvdCcpOyAvKiBJRTkgQ29tcGF0IE1vZGVzICovDQogIC8vc3JjOiB1cmwoJ1lvdXJXZWJGb250TmFtZS5lb3Q/I2llZml4JykgZm9ybWF0KCdlbWJlZGRlZC1vcGVudHlwZScpLCAvKiBJRTYtSUU4ICovDQogIHNyYzogdXJsKCcuLi9wdWJsaWMvY3NzL0xpU2h1L0xpU2h1LndvZmYnKSBmb3JtYXQoJ3dvZmYnKSwgLyogTW9kZXJuIEJyb3dzZXJzICovDQogIHVybCgnLi4vcHVibGljL2Nzcy9MaVNodS9MaVNodS50dGYnKSAgZm9ybWF0KCd0cnVldHlwZScpLCAvKiBTYWZhcmksIEFuZHJvaWQsIGlPUyAqLw0KICB1cmwoIi4uL3B1YmxpYy9jc3MvTGlTaHUvTGlTaHUuc3ZnIikgIGZvcm1hdCgnc3ZnJyk7IC8qIExlZ2FjeSBpT1MgKi8NCn0NCg=="},{"version":3,"sources":["Chess1.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAizCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Chess1.vue","sourceRoot":"docs/.vuepress/components","sourcesContent":["<template>\r\n  <div>\r\n    <div class=\"chessBoard\">\r\n      <div class=\"imgBox myImgBox\" v-for=\"(item,index) in 90\">\r\n        <img :src=\"$withBase(`/img/chess/K_.png`)\"\r\n             :id=\"`pos${index}`\" alt=\"一个棋子\"\r\n             :key=\"index\">\r\n      </div>\r\n      <div class=\"myFontBox\">\r\n        <div class=\"css2ebd673af7243b7\">楚河</div>\r\n        <div class=\"css2ebd673af7243b7\">汉界</div>\r\n      </div>\r\n    </div>\r\n    <ul class=\"audioBx\" style=\"display: none\">\r\n      <li><audio id=\"skill1\" :src=\"$withBase(`/music/兵线刷新.mp3`)\"></audio></li>\r\n      <li><audio id=\"skill2\" :src=\"$withBase(`/music/替父从军.mp3`)\"></audio></li>\r\n      <li><audio id=\"skill3\" :src=\"$withBase(`/music/草木皆兵.mp3`)\"></audio></li>\r\n    </ul>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport $ from 'jquery'\r\n\r\nexport default {\r\n  name: \"Chess\",\r\n  props: {\r\n    displayChess: {\r\n      type: Array,\r\n      default: [\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,//3\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,//12\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n      ],\r\n    },\r\n    playerSide: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    isSelectMachine: {\r\n      type: Boolean,\r\n      default: false\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      visible: false,\r\n      test: [],\r\n      IN_BOARD_: [\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n      ],\r\n      IN_FORT_: [//辅助数组，标识是否在九宫内\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n      ],\r\n      displayChessTemp: [\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,//3\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\r\n        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,//12\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n      ],\r\n      FEN: 'rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR',\r\n      FENArray: [],\r\n      userInputFEN: '',\r\n      userInput: '',\r\n      sqSelected: 0,//鼠标是否选中一棋子\r\n      currentChess: '',//当前选中的棋子，的首字母,\r\n      displayChess_Old: []\r\n    }\r\n  },\r\n  computed: {\r\n    imgDomArr() {\r\n      return document.querySelectorAll('div.imgBox img')\r\n    },\r\n  },\r\n  watch: {\r\n    displayChess: {\r\n      handler(val, oldVal) {\r\n        this.displayChess_Old = oldVal.map((item) => {return item})\r\n        this.displayChessTemp = val.map(item => {return item})\r\n        let start = this.COORD_XY(3, 3) //51,循环开始处\r\n        let end = this.COORD_XY(11, 12) //203，循环结束处\r\n        /*tag用作记录文件名关键信息；\r\n        **row是当前循环索引值i对应的二维坐标的行数,col是列数；\r\n        **imgIndex用于记录i对应第几个图片*/\r\n        let tag = '', row = 0, imgIndex = 0, col = 0;\r\n        for (let i = start; i <= end; i++) {\r\n          if (this.IN_BOARD(i)) {\r\n            switch (val[i]) {\r\n              case 8:\r\n                tag = 'K';\r\n                break;\r\n              case 9:\r\n                tag = 'A';\r\n                break;\r\n              case 10:\r\n                tag = 'B';\r\n                break;\r\n              case 11:\r\n                tag = 'N';\r\n                break;\r\n              case 12:\r\n                tag = 'R';\r\n                break;\r\n              case 13:\r\n                tag = 'C';\r\n                break;\r\n              case 14:\r\n                tag = 'P';\r\n                break;\r\n\r\n              case 16:\r\n                tag = 'k_';\r\n                break;\r\n              case 17:\r\n                tag = 'a_';\r\n                break;\r\n              case 18:\r\n                tag = 'b_';\r\n                break;\r\n              case 19:\r\n                tag = 'n_';\r\n                break;\r\n              case 20:\r\n                tag = 'r_';\r\n                break;\r\n              case 21:\r\n                tag = 'c_';\r\n                break;\r\n              case 22:\r\n                tag = 'p_';\r\n                break;\r\n              case 1:\r\n                tag = 'UNexist';\r\n                break;\r\n              case 0:\r\n                tag = 'UNexist'\r\n                break;\r\n              default:\r\n                tag = 'UNexist'\r\n            }\r\n            row = this.RANK_Y(i)\r\n            col = this.FILE_X(i)\r\n            imgIndex = i - 7 * row - 30\r\n            let imgSrcStr = `/img/chess/${tag}.png`;\r\n            this.imgDomArr[imgIndex].src = imgSrcStr\r\n            /*清空变量*/\r\n            tag = '';\r\n            row = 0;\r\n            imgIndex = 0\r\n          }\r\n        }\r\n        // console.log(this.imgDomArr[0].src);\r\n      },\r\n      // deep: true\r\n    },\r\n    async playerSide(newVal,oldVal) {\r\n      if(!newVal && this.isSelectMachine) {//表示黑方走棋且选择了人机对战\r\n        // let skill = await this.machine_passiveSkills()\r\n        let skill = 0\r\n        if(skill === 1) {\r\n          this.$message.warning('触发被动技能：兵线刷新')\r\n        }\r\n        else if(skill === 2) {\r\n          this.$message.warning('触发被动技能：替父从军')\r\n        }\r\n        else if(skill === 3) {\r\n          this.$message.warning('触发被动技能：草木皆兵')\r\n        }\r\n        else if(skill === 0) {\r\n          // let dom1 = $('#pos8')\r\n          let dom1 = this.machine_getPcToBeMoved()\r\n          // let dom2 = this.machine_getSteps(dom1)[0]\r\n          let dom2 = this.machine_getExactStep(dom1)\r\n          this.$message.success('电脑移动了' + this.ImgNameToChessName(dom1.attr('src').slice(11,12)))\r\n\r\n          this.machineMove(dom1,dom2)\r\n          // console.log(dom1);\r\n          // console.log(dom2);\r\n          // console.log(this.machine_getSteps(dom1));\r\n        }\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    // const css = document.createElement('link');\r\n    // css.rel = 'stylesheet';\r\n    // css.href = 'https://cdn.repository.webfont.com/webfonts/nomal/148407/46489/625407aaf629d81300ac19b3.css';\r\n    // document.body.appendChild(css);\r\n\r\n    this.initBoard()\r\n    /*每个img绑定一个点击事件*/\r\n    document.querySelectorAll('div.imgBox img').forEach((e, index) => {\r\n      e.addEventListener('mousedown', (e, index) => {\r\n        let fileName = e.target.src.slice(32, 33)\r\n        // console.log(fileName);\r\n        let alertStr = this.ImgNameToChessName(fileName)\r\n\r\n        let imgIndex = parseInt(e.target.id.slice(3)) + 1\r\n        // console.log(imgIndex);\r\n        // console.log(this.displayChessTemp);\r\n        let chessInfo = {//棋子的一些信息\r\n          displayChess: this.displayChessTemp,\r\n          fileName: fileName,\r\n          imgIndex: imgIndex,\r\n          sqSelected: this.imgIndexToSq(imgIndex)\r\n        }\r\n\r\n        this.chess1Click(chessInfo)\r\n\r\n        /*用户每次点击棋子应该将该棋子储存到当前棋子currentChess*/\r\n        // this.currentChess = fileName\r\n        // if(this.sqSelected) {\r\n        //   if(this.currentChess != 'U') {\r\n        //     console.log('上次点击的是空白处');\r\n        //   }\r\n        // }\r\n      })\r\n    })\r\n\r\n  },\r\n  methods: {\r\n    /*传入一维坐标，如果在棋盘内，返回true*/\r\n    IN_BOARD(sq) {\r\n      return this.IN_BOARD_[sq] !== 0;\r\n    },\r\n    /*判断是否在九宫格内,若是，返回true*/\r\n    IN_FORT(sq) {\r\n      return this.IN_FORT_[sq] !== 0;\r\n    },\r\n    /*将二维矩阵坐标转换为一维矩阵坐标 (x,y)含(0,0)*/\r\n    COORD_XY(x, y) {// 将二维矩阵坐标转换为一维矩阵坐标 (x,y)含(0,0)\r\n      return x + (y << 4);\r\n    },\r\n    /*根据一维矩阵，获取二维矩阵行数 行数从0开始*/\r\n    RANK_Y(sq) {// 根据一维矩阵，获取二维矩阵行数 行数从0开始\r\n      return sq >> 4;\r\n    },\r\n    /*根据一维矩阵，获取二维矩阵列数*/\r\n    FILE_X(sq) {// 根据一维矩阵，获取二维矩阵列数\r\n      return sq & 15;\r\n    },\r\n    /*初始化棋盘，得到棋盘一开始的布局*/\r\n    initBoard() {\r\n      this.displayChessTemp = []//清空一下棋盘\r\n      this.FENArray = this.FEN.split('') //将FEN字符串转为数组\r\n\r\n      this.FENtoBoard(this.FENArray)//将FEN串(array型)转化为一维数组形式，并且字符元素映射为整型,保存在this.displayChessTemp\r\n      for (let i = 0; i < 256; i++) {//将棋盘外元素设置为null\r\n        if (!this.IN_BOARD(i)) {\r\n          this.displayChessTemp[i] = null\r\n        }\r\n      }\r\n      let start = this.COORD_XY(3, 3) //51,循环开始处\r\n      let end = this.COORD_XY(11, 12) //203，循环结束处\r\n      // let imgDomArr = document.querySelectorAll('div.imgBox img')\r\n      /*tag用作记录文件名关键信息；\r\n      **row是当前循环索引值i对应的二维坐标的行数,col是列数；\r\n      **imgIndex用于记录i对应第几个图片*/\r\n      let tag = '', row = 0, imgIndex = 0, col = 0;\r\n      for (let i = start; i <= end; i++) {\r\n        if (this.IN_BOARD(i)) {\r\n          switch (this.displayChessTemp[i]) {\r\n            case 8:\r\n              tag = 'K';\r\n              break;\r\n            case 9:\r\n              tag = 'A';\r\n              break;\r\n            case 10:\r\n              tag = 'B';\r\n              break;\r\n            case 11:\r\n              tag = 'N';\r\n              break;\r\n            case 12:\r\n              tag = 'R';\r\n              break;\r\n            case 13:\r\n              tag = 'C';\r\n              break;\r\n            case 14:\r\n              tag = 'P';\r\n              break;\r\n\r\n            case 16:\r\n              tag = 'k_';\r\n              break;\r\n            case 17:\r\n              tag = 'a_';\r\n              break;\r\n            case 18:\r\n              tag = 'b_';\r\n              break;\r\n            case 19:\r\n              tag = 'n_';\r\n              break;\r\n            case 20:\r\n              tag = 'r_';\r\n              break;\r\n            case 21:\r\n              tag = 'c_';\r\n              break;\r\n            case 22:\r\n              tag = 'p_';\r\n              break;\r\n            case 1:\r\n              tag = 'UNexist';\r\n              break;\r\n            case 0:\r\n              tag = 'UNexist'\r\n              break;\r\n            default:\r\n              tag = 'UNexist'\r\n          }\r\n          row = this.RANK_Y(i)\r\n          col = this.FILE_X(i)\r\n          imgIndex = i - 7 * row - 30\r\n          let imgSrcStr = `/img/chess/${tag}.png`;\r\n          this.imgDomArr[imgIndex].src = imgSrcStr\r\n          /*清空变量*/\r\n          tag = '';\r\n          row = 0;\r\n          imgIndex = 0\r\n        } else continue\r\n      }\r\n\r\n    },\r\n    /*将FEN串(array型)转化为一维数组形式，并且字符元素映射为整型,保存在this.displayChessTemp*/\r\n    FENtoBoard(FENArray) {\r\n      let x = 3, y = 3\r\n      for (let i in FENArray) {\r\n        let ch = FENArray[i]\r\n        if (ch === '/') {//换行\r\n          y++\r\n        }\r\n        if (y > 12) break\r\n        if (x > 11) x = 3\r\n        else if (ch >= '1' && ch <= '9') {//出现空位\r\n          x += parseInt(ch)\r\n        } else if ((ch >= 'a' && ch <= 'z')) {//红方棋子或黑方棋子\r\n          let index = x + (y << 4)\r\n          this.displayChessTemp[index] = this.FENCharToNum(ch)\r\n          x++\r\n        } else if (ch >= 'A' && ch <= 'Z') {\r\n          let index = x + (y << 4)\r\n          this.displayChessTemp[index] = this.FENCharToNum(ch)\r\n          x++\r\n        } else console.log('err');\r\n      }\r\n    },\r\n    /*将棋子字符转成对应的整数*/\r\n    FENCharToNum(item) {//将棋子字符转成对应的整数\r\n      switch (item) {\r\n        case 'K' : {\r\n          return 8;\r\n        }\r\n        case 'A':\r\n          return 9;\r\n        case 'B':\r\n          return 10;\r\n        case 'N':\r\n          return 11;\r\n        case 'R':\r\n          return 12;\r\n        case 'C':\r\n          return 13;\r\n        case 'P':\r\n          return 14;\r\n\r\n        case 'k':\r\n          return 16;\r\n        case 'a':\r\n          return 17;\r\n        case 'b':\r\n          return 18;\r\n        case 'n':\r\n          return 19;\r\n        case 'r':\r\n          return 20;\r\n        case 'c':\r\n          return 21;\r\n        case 'p':\r\n          return 22;\r\n        default:\r\n          return 'err'\r\n      }\r\n    },\r\n    /*根据字符，返回图片文件名(的关键信息)*/\r\n    FENCharToImg(ch) {\r\n      switch (ch) {\r\n        case 'K' : {\r\n          return 'K';\r\n        }\r\n        case 'A':\r\n          return 'A';\r\n        case 'B':\r\n          return 'B';\r\n        case 'N':\r\n          return 'N';\r\n        case 'R':\r\n          return 'R';\r\n        case 'C':\r\n          return 'C';\r\n        case 'P':\r\n          return 'P';\r\n\r\n        case 'k':\r\n          return 'k_';\r\n        case 'a':\r\n          return 'a_';\r\n        case 'b':\r\n          return 'b_';\r\n        case 'n':\r\n          return 'n_';\r\n        case 'r':\r\n          return 'r_';\r\n        case 'c':\r\n          return 'c_';\r\n        case 'p':\r\n          return 'p_';\r\n        default:\r\n          return 'err'\r\n      }\r\n    },\r\n    /*根据棋子图片文件名，返回棋子中文字符串*/\r\n    ImgNameToChessName(imgName) {\r\n      switch (imgName) {\r\n        case 'K' : {\r\n          return '红方_帅';\r\n        }\r\n        case 'A':\r\n          return '红方_士';\r\n        case 'B':\r\n          return '红方_相';\r\n        case 'N':\r\n          return '红方_马';\r\n        case 'R':\r\n          return '红方_车';\r\n        case 'C':\r\n          return '红方_炮';\r\n        case 'P':\r\n          return '红方_兵';\r\n\r\n        case 'k':\r\n          return '黑方_将';\r\n        case 'a':\r\n          return '黑方_仕';\r\n        case 'b':\r\n          return '黑方_象';\r\n        case 'n':\r\n          return '黑方_马';\r\n        case 'r':\r\n          return '黑方_车';\r\n        case 'c':\r\n          return '黑方_炮';\r\n        case 'p':\r\n          return '黑方_卒';\r\n        default:\r\n          return '空'\r\n      }\r\n    },\r\n    /*根据FEN串绘制棋盘*/\r\n    drawWithFEN(FEN) {\r\n      this.FENArray = []\r\n      this.FENArray = FEN.split('')\r\n      this.displayChessTemp = []\r\n      this.FENtoBoard(this.FENArray)\r\n      // console.log(this.displayChessTemp);\r\n      for (let i = 0; i < 256; i++) {//将棋盘外元素设置为null\r\n        if (!this.IN_BOARD(i)) {\r\n          this.displayChessTemp[i] = null\r\n        }\r\n      }\r\n      let start = this.COORD_XY(3, 3) //51,循环开始处\r\n      let end = this.COORD_XY(11, 12) //203，循环结束处\r\n      // this.imgDomArr = document.querySelectorAll('div.imgBox img')\r\n      /*tag用作记录文件名关键信息；\r\n      **row是当前循环索引值i对应的二维坐标的行数,col是列数；\r\n      **imgIndex用于记录i对应第几个图片*/\r\n      let tag = '', row = 0, imgIndex = 0, col = 0;\r\n      for (let i = start; i <= end; i++) {\r\n        if (this.IN_BOARD(i)) {\r\n          switch (this.displayChessTemp[i]) {\r\n            case 8:\r\n              tag = 'K';\r\n              break;\r\n            case 9:\r\n              tag = 'A';\r\n              break;\r\n            case 10:\r\n              tag = 'B';\r\n              break;\r\n            case 11:\r\n              tag = 'N';\r\n              break;\r\n            case 12:\r\n              tag = 'R';\r\n              break;\r\n            case 13:\r\n              tag = 'C';\r\n              break;\r\n            case 14:\r\n              tag = 'P';\r\n              break;\r\n\r\n            case 16:\r\n              tag = 'k_';\r\n              break;\r\n            case 17:\r\n              tag = 'a_';\r\n              break;\r\n            case 18:\r\n              tag = 'b_';\r\n              break;\r\n            case 19:\r\n              tag = 'n_';\r\n              break;\r\n            case 20:\r\n              tag = 'r_';\r\n              break;\r\n            case 21:\r\n              tag = 'c_';\r\n              break;\r\n            case 22:\r\n              tag = 'p_';\r\n              break;\r\n            case 1:\r\n              tag = 'UNexist';\r\n              break;\r\n            case 0:\r\n              tag = 'UNexist'\r\n              break;\r\n            default:\r\n              tag = 'UNexist'\r\n          }\r\n          row = this.RANK_Y(i)\r\n          col = this.FILE_X(i)\r\n          imgIndex = i - 7 * row - 30\r\n          let imgSrcStr = `/img/chess/${tag}.png`;\r\n          this.imgDomArr[imgIndex].src = imgSrcStr // 重新渲染棋子图片\r\n          /*清空变量*/\r\n          tag = '';\r\n          row = 0;\r\n          imgIndex = 0\r\n        }\r\n      }\r\n\r\n    },\r\n    /*根据displayChessTemp重新绘制局面*/\r\n    drawWithSq() {\r\n      let start = this.COORD_XY(3, 3) //51,循环开始处\r\n      let end = this.COORD_XY(11, 12) //203，循环结束处\r\n      // this.imgDomArr = document.querySelectorAll('div.imgBox img')\r\n      /*tag用作记录文件名关键信息；\r\n      **row是当前循环索引值i对应的二维坐标的行数,col是列数；\r\n      **imgIndex用于记录i对应第几个图片*/\r\n      let tag = '', row = 0, imgIndex = 0, col = 0;\r\n      for (let i = start; i <= end; i++) {\r\n        if (this.IN_BOARD(i)) {\r\n          switch (this.displayChessTemp[i]) {\r\n            case 8:\r\n              tag = 'K';\r\n              break;\r\n            case 9:\r\n              tag = 'A';\r\n              break;\r\n            case 10:\r\n              tag = 'B';\r\n              break;\r\n            case 11:\r\n              tag = 'N';\r\n              break;\r\n            case 12:\r\n              tag = 'R';\r\n              break;\r\n            case 13:\r\n              tag = 'C';\r\n              break;\r\n            case 14:\r\n              tag = 'P';\r\n              break;\r\n\r\n            case 16:\r\n              tag = 'k_';\r\n              break;\r\n            case 17:\r\n              tag = 'a_';\r\n              break;\r\n            case 18:\r\n              tag = 'b_';\r\n              break;\r\n            case 19:\r\n              tag = 'n_';\r\n              break;\r\n            case 20:\r\n              tag = 'r_';\r\n              break;\r\n            case 21:\r\n              tag = 'c_';\r\n              break;\r\n            case 22:\r\n              tag = 'p_';\r\n              break;\r\n            case 1:\r\n              tag = 'UNexist';\r\n              break;\r\n            case 0:\r\n              tag = 'UNexist'\r\n              break;\r\n            default:\r\n              tag = 'UNexist'\r\n          }\r\n          row = this.RANK_Y(i)\r\n          col = this.FILE_X(i)\r\n          imgIndex = i - 7 * row - 30\r\n          let imgSrcStr = `/img/chess/${tag}.png`;\r\n          this.imgDomArr[imgIndex].src = imgSrcStr // 重新渲染棋子图片\r\n          /*清空变量*/\r\n          tag = '';\r\n          row = 0;\r\n          imgIndex = 0\r\n        }\r\n      }\r\n    },\r\n    /*将第几个图片标签转换为sq*/\r\n    imgIndexToSq(imgIndex) {\r\n      let row = Math.floor((imgIndex - 1) / 9) + 3\r\n      return imgIndex + 30 + 7 * row - 1\r\n      // console.log('sq:' + sq);\r\n    },\r\n    /*如果从起点sqSrc到终点sqDst没有过河，则返回true；否则返回false*/\r\n    SAME_HALF(sqSrc, sqDst) {// 如果从起点sqSrc到终点sqDst没有过河，则返回true；否则返回false\r\n      return ((sqSrc ^ sqDst) & 0x80) === 0;\r\n    },\r\n    /*电脑走棋\r\n    * dom:电脑操控模拟鼠标点击处的dom对象(实际上是调用了chess1Click函数，没有点击)\r\n    * 1代表起点，2代表终点\r\n    * 实现效果为棋子移动\r\n    * */\r\n    machineMove(dom1,dom2){\r\n      let fileName1 = dom1.attr('src').slice(11, 12)\r\n      let imgIndex1 = parseInt(dom1.attr('id').slice(3)) + 1\r\n      let chessInfo1 = {//棋子的一些信息\r\n        displayChess: this.displayChessTemp,\r\n        fileName: fileName1,\r\n        imgIndex: imgIndex1,\r\n        sqSelected: this.imgIndexToSq(imgIndex1)\r\n      }\r\n      this.chess1Click(chessInfo1)//相当于鼠标点击了pos0车的位置\r\n\r\n      setTimeout(() => {\r\n        let fileName2 = dom2.attr('src').slice(11, 12)\r\n        let imgIndex2 = parseInt(dom2.attr('id').slice(3)) + 1\r\n        let chessInfo2 = {//棋子的一些信息\r\n          displayChess: this.displayChessTemp,\r\n          fileName: fileName2,\r\n          imgIndex: imgIndex2,\r\n          sqSelected: this.imgIndexToSq(imgIndex2)\r\n        }\r\n        this.chess1Click(chessInfo2)\r\n      },500)\r\n\r\n    },\r\n    /*根据输入的棋子dom对象，返回该棋子所有可能的下一步走法（array型，但数组元素为dom对象）*/\r\n    machine_getSteps(dom) {\r\n      let step = []\r\n      let fileName = dom.attr('src').slice(11, 12)\r\n      let sqSrc = this.imgIndexToSq(parseInt(dom.attr('id').slice(3)) + 1)//获取一维坐标\r\n      switch (fileName) {\r\n        case 'k': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i in KING_DELTA) {// 将的4个方向\r\n            let sqDst = sqSrc + KING_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst)) {//终点处不在棋盘内\r\n              continue\r\n            }\r\n            if(this.displayChessTemp[sqDst] < 16 && this.IN_FORT(sqDst)) {\r\n              //终点处没有棋子没有本方（黑方）棋子，且终点在九宫格内\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'a': {\r\n          let ADVISOR_DELTA = [-15, -17, 17, 15];\r\n          for(let i in ADVISOR_DELTA) {\r\n            let sqDst = sqSrc + ADVISOR_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst) ) {//终点处不在棋盘内，或不在九宫格内\r\n              continue\r\n            }\r\n            if(this.displayChessTemp[sqDst] < 16 && this.IN_FORT(sqDst)) {\r\n              //终点处没有棋子没有本方（黑方）棋子,且终点在九宫格内\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'b': {\r\n          let BISHOP_DELTA = [-34, -30, 30, 34];\r\n          for(let i in BISHOP_DELTA) {\r\n            let sqDst = sqSrc + BISHOP_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst) || !this.SAME_HALF(sqSrc,sqDst)\r\n                || this.displayChessTemp[(sqSrc+sqDst)/2] > 1) {\r\n              //终点处不在棋盘内,或过河,或象眼无棋子\r\n              continue\r\n            }\r\n            if(this.displayChessTemp[sqDst] < 16) {\r\n              //终点处没有棋子没有本方（黑方）棋子\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'n': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          let KNIGHT_DELTA = [[-33, -31], [-18, 14], [-14, 18], [31, 33]];\r\n          for(let i in KNIGHT_DELTA) {// 马腿的4个方向\r\n            let sqDst = sqSrc + KING_DELTA[i]; // 得到一个马腿的位置\r\n            if(this.displayChessTemp[sqDst] > 1) {\r\n              //马脚处有棋子\r\n              continue\r\n            }\r\n            for (let j = 0; j < 2; j ++) { // 1个马腿对应2个马的方向\r\n              sqDst = sqSrc + KNIGHT_DELTA[i][j]; // 得到一个马的可能的终点位置\r\n              if (!this.IN_BOARD(sqDst)) {\r\n                continue;\r\n              }\r\n              if(this.displayChessTemp[sqDst] < 16) {\r\n                //终点处没有棋子没有本方（黑方）棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'r': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i = 0; i < 4; i ++) {\r\n            let delta = KING_DELTA[i];    // 得到一个方向\r\n            let sqDst = sqSrc + delta;    // 从起点sqSrc开始，沿着方向delta走一步\r\n            while (this.IN_BOARD(sqDst)) {\r\n              //在棋盘上\r\n              if(this.displayChessTemp[sqDst] < 16) {\r\n                //终点处没有棋子没有本方（黑方）棋子,或有红方棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n                if(this.displayChessTemp[sqDst] >= 8) {\r\n                  //终点处有对方（红方）棋子\r\n                  break\r\n                }\r\n              }\r\n              else break\r\n              sqDst += delta;     // 沿着方向delta向前走一步\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'c': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i = 0; i < 4; i ++) {\r\n            let delta = KING_DELTA[i];    // 得到一个方向\r\n            let sqDst = sqSrc + delta;    // 从起点sqSrc开始，沿着方向delta走一步\r\n            while (this.IN_BOARD(sqDst)) {\r\n              if(this.displayChessTemp[sqDst] === 1) {\r\n                //终点处没有棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n              else {            // 终点存在棋子，炮需要翻山\r\n                break;\r\n              }\r\n              sqDst += delta;     // 沿着方向delta向前走一步\r\n            }\r\n            sqDst += delta;       // 沿着方向delta向前走一步\r\n            while (this.IN_BOARD(sqDst)) { // 如果sqDst仍位于棋盘，那么此时炮已经翻山了\r\n              if(this.displayChessTemp[sqDst] >= 8 && this.displayChessTemp[sqDst] < 16) {\r\n                //终点处是红方棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row - 29 - 1\r\n                let domTemp = $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n                break\r\n              }\r\n              sqDst += delta;\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'p': {\r\n          let PAWN_delta = [16,1,-1] //兵一开始只能向下走,过河后可向左/右走\r\n          let sqDst = sqSrc + PAWN_delta[0]\r\n          if(this.displayChessTemp[sqDst] < 16) {//终点处不是黑方棋子\r\n            let row = this.RANK_Y(sqDst)\r\n            let imgIndex = sqDst - 7*row -29 - 1\r\n            let domTemp =  $('#pos' + imgIndex)\r\n            step.push(domTemp)\r\n          }\r\n          if(sqSrc >= 131) {//若兵过河了(此处的131是经过计算得到的过河临界值\r\n            for (let i = 0; i < 2; i++) {\r\n              sqDst = sqSrc + PAWN_delta[i+1]\r\n              if(this.displayChessTemp[sqDst] < 16) {\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n            }\r\n          }\r\n          break\r\n        }\r\n\r\n        case 'K': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i in KING_DELTA) {// 将的4个方向\r\n            let sqDst = sqSrc + KING_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst)) {//终点处不在棋盘内\r\n              continue\r\n            }\r\n            if(!(this.displayChessTemp[sqDst] & 8) && this.IN_FORT(sqDst)) {\r\n              //终点处没有棋子没有本方（红方）棋子，且终点在九宫格内\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'A': {\r\n          let ADVISOR_DELTA = [-15, -17, 17, 15];\r\n          for(let i in ADVISOR_DELTA) {\r\n            let sqDst = sqSrc + ADVISOR_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst) ) {//终点处不在棋盘内，或不在九宫格内\r\n              continue\r\n            }\r\n            if(!(this.displayChessTemp[sqDst] & 8) && this.IN_FORT(sqDst)) {\r\n              //终点处没有棋子没有本方（红方）棋子,且终点在九宫格内\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'B': {\r\n          let BISHOP_DELTA = [-34, -30, 30, 34];\r\n          for(let i in BISHOP_DELTA) {\r\n            let sqDst = sqSrc + BISHOP_DELTA[i]; // 得到一个可能的终点位置\r\n            if(!this.IN_BOARD(sqDst) || !this.SAME_HALF(sqSrc,sqDst)\r\n                || this.displayChessTemp[(sqSrc+sqDst)/2] > 1) {\r\n              //终点处不在棋盘内,或过河,或象眼无棋子\r\n              continue\r\n            }\r\n            if(!(this.displayChessTemp[sqDst] & 8)) {\r\n              //终点处没有棋子没有本方（红方）棋子\r\n              let row = this.RANK_Y(sqDst)\r\n              let imgIndex = sqDst - 7*row -29 - 1\r\n              let domTemp =  $('#pos' + imgIndex)\r\n              step.push(domTemp)\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'N': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          let KNIGHT_DELTA = [[-33, -31], [-18, 14], [-14, 18], [31, 33]];\r\n          for(let i in KNIGHT_DELTA) {// 马腿的4个方向\r\n            let sqDst = sqSrc + KING_DELTA[i]; // 得到一个马腿的位置\r\n            if(this.displayChessTemp[sqDst] > 1) {\r\n              //马脚处有棋子\r\n              continue\r\n            }\r\n            for (let j = 0; j < 2; j ++) { // 1个马腿对应2个马的方向\r\n              sqDst = sqSrc + KNIGHT_DELTA[i][j]; // 得到一个马的可能的终点位置\r\n              if (!this.IN_BOARD(sqDst)) {\r\n                continue;\r\n              }\r\n              if(!(this.displayChessTemp[sqDst] & 8)) {\r\n                //终点处没有棋子没有本方（红方）棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'R': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i = 0; i < 4; i ++) {\r\n            let delta = KING_DELTA[i];    // 得到一个方向\r\n            let sqDst = sqSrc + delta;    // 从起点sqSrc开始，沿着方向delta走一步\r\n            while (this.IN_BOARD(sqDst)) {\r\n              //在棋盘上\r\n              if(!(this.displayChessTemp[sqDst] & 8)) {\r\n                //终点处没有棋子没有本方（红方）棋子,或有红方棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n                if(this.displayChessTemp[sqDst] & 16) {\r\n                  //终点处有对方（黑方）棋子\r\n                  break\r\n                }\r\n              }\r\n              else break\r\n              sqDst += delta;     // 沿着方向delta向前走一步\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'C': {\r\n          let KING_DELTA= [-16, -1, 1, 16];\r\n          for (let i = 0; i < 4; i ++) {\r\n            let delta = KING_DELTA[i];    // 得到一个方向\r\n            let sqDst = sqSrc + delta;    // 从起点sqSrc开始，沿着方向delta走一步\r\n            while (this.IN_BOARD(sqDst)) {\r\n              if(this.displayChessTemp[sqDst] === 1) {\r\n                //终点处没有棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n              else {            // 终点存在棋子，炮需要翻山\r\n                break;\r\n              }\r\n              sqDst += delta;     // 沿着方向delta向前走一步\r\n            }\r\n            sqDst += delta;       // 沿着方向delta向前走一步\r\n            while (this.IN_BOARD(sqDst)) { // 如果sqDst仍位于棋盘，那么此时炮已经翻山了\r\n              if(this.displayChessTemp[sqDst] & 16) {\r\n                //终点处是黑方棋子\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row - 29 - 1\r\n                let domTemp = $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n                break\r\n              }\r\n              sqDst += delta;\r\n            }\r\n          }\r\n          break\r\n        }\r\n        case 'P': {\r\n          let PAWN_delta = [-16,1,-1] //兵一开始只能向上走,过河后可向左/右走\r\n          let sqDst = sqSrc + PAWN_delta[0]\r\n          if(!(this.displayChessTemp[sqDst] & 8)) {//终点处不是红方棋子,则走法合法\r\n            let row = this.RANK_Y(sqDst)\r\n            let imgIndex = sqDst - 7*row -29 - 1\r\n            let domTemp =  $('#pos' + imgIndex)\r\n            step.push(domTemp)\r\n          }\r\n          if(sqSrc < 131) {//若兵过河了(此处的131是经过计算得到的过河临界值\r\n            for (let i = 0; i < 2; i++) {\r\n              sqDst = sqSrc + PAWN_delta[i+1]\r\n              if(!(this.displayChessTemp[sqDst] & 8)) {\r\n                let row = this.RANK_Y(sqDst)\r\n                let imgIndex = sqDst - 7*row -29 - 1\r\n                let domTemp =  $('#pos' + imgIndex)\r\n                step.push(domTemp)\r\n              }\r\n            }\r\n          }\r\n          break\r\n        }\r\n        default: step.push(null)\r\n      }\r\n      return step\r\n    },\r\n    /*根据局面评估值，返回下一步要走的棋子*/\r\n    machine_getPcToBeMoved() {\r\n      let blackAllPc = [], whiteAllPc = []\r\n      let displayChess_evaluate = this.displayChessTemp.map(item => {return item})\r\n      //该循环得到所有可以选择走的棋子，的一维坐标\r\n      for(let sqSrc in this.displayChessTemp) {\r\n        if(this.displayChessTemp[sqSrc] & 16) {\r\n          blackAllPc.push(sqSrc)\r\n        }\r\n        else if(this.displayChessTemp[sqSrc] & 8) whiteAllPc.push(sqSrc)\r\n      }\r\n      let randomIndex\r\n      let randomSrcDom//起点,终点\r\n      let val1 = 0\r\n      let minMaxVal2_sqSrc = blackAllPc[0]//使maxVal2最小时的棋子的起点一维坐标(黑方执棋)\r\n      for(let i in blackAllPc) {\r\n        let sqSrc = blackAllPc[i]//某个黑方棋子的起点一维坐标\r\n        console.log('一黑方棋子的起点:');\r\n        console.log(this.sqToDom(sqSrc));\r\n        console.log('一黑方棋子的终点：');\r\n        /*走法数组，元素为对象类型*/\r\n        let stepArray = this.machine_getSteps(this.sqToDom(sqSrc)).map(e => {return e})\r\n        for(let j in stepArray) {\r\n          console.log(stepArray[j]);\r\n          /*该黑方棋子其中一个走法的终点，的一维坐标*/\r\n          let sqDst = this.domToSq(stepArray[j])\r\n          let tempNum = displayChess_evaluate[sqDst] //保存一下落子前终点处的棋子Num\r\n          displayChess_evaluate[sqDst] = displayChess_evaluate[sqSrc] //假设落子了\r\n          displayChess_evaluate[sqSrc] = 1//原来的起点变为空\r\n          val1 = this.machine_evaluate(displayChess_evaluate)//黑方走完，试求评估值1\r\n          /*站在黑方的角度，我肯定力求val1最小,maxVal2最小*/\r\n          let val2 = 0, maxVal2 = 0, maxVal2_sqSrc2 = 137\r\n          for(let k in whiteAllPc) {\r\n            //轮到红方走棋\r\n            let sqSrc2 = whiteAllPc[k]//某个红方棋子的起点一维坐标\r\n            // console.log(sqSrc2);\r\n            let DstDom = this.machine_getExactStep(this.sqToDom(sqSrc2))\r\n            console.log('一红方棋子的起点:');\r\n            console.log(this.sqToDom(sqSrc2));\r\n            console.log('一红方棋子的终点:');\r\n            console.log(DstDom);\r\n            if(DstDom === undefined) break //如果遍历到的红方棋子一种走法都没有，就跳过\r\n            // console.log(DstDom);\r\n            /*该红方棋子最佳走法的终点一维坐标*/\r\n            let sqDst2 = this.domToSq(DstDom)\r\n            // console.log(sqDst2);\r\n            let tempNum2 = displayChess_evaluate[sqDst2]//保存一下落子前终点处的棋子Num\r\n            displayChess_evaluate[sqDst2] = displayChess_evaluate[sqSrc2] //假设落子了\r\n            displayChess_evaluate[sqSrc2] = 1//原来的起点变为空\r\n            val2 = this.machine_evaluate(displayChess_evaluate)//试求评估值2\r\n            console.log('假设该红方棋子落子后的评估值：' + val2);\r\n            /*站在红方的角度，我肯定力求val2最大*/\r\n            if(val2 > maxVal2) {\r\n              maxVal2 = val2 //更新最大评估值\r\n              maxVal2_sqSrc2 = sqSrc2//更新评估值最大时选择的棋子\r\n              minMaxVal2_sqSrc = sqSrc\r\n              console.log(sqSrc);\r\n              console.log(maxVal2);\r\n              console.log('黑方最优的走棋的起点');\r\n              console.log(this.sqToDom(minMaxVal2_sqSrc));\r\n            }\r\n            else {\r\n              // minMaxVal2_sqSrc = blackAllPc[i]\r\n              console.log('error');\r\n            }\r\n            displayChess_evaluate[sqSrc2] = displayChess_evaluate[sqDst2]//恢复中转棋盘\r\n            displayChess_evaluate[sqDst2] = tempNum2//恢复中转棋盘\r\n            // break\r\n          }\r\n\r\n          displayChess_evaluate[sqSrc] = displayChess_evaluate[sqDst]//恢复中转棋盘\r\n          displayChess_evaluate[sqDst] = tempNum//恢复中转棋盘\r\n          // break\r\n        }\r\n        // break\r\n      }\r\n\r\n      // while(1) {\r\n      //   randomIndex = Math.floor(Math.random() * blackAllPc.length)//随机数在数组中的索引值\r\n      //   // let randomSq = blackAllPc[randomIndex]\r\n      //   randomSrcDom = this.sqToDom(blackAllPc[randomIndex])\r\n      //   if(this.machine_getSteps(randomSrcDom).length > 0)\r\n      //     //当选中的棋子至少有一种走法时，才退出循环，否则一直循环直到找到一棋子其走法有至少一种\r\n      //     break\r\n      // }\r\n\r\n      // return randomSrcDom\r\n      return this.sqToDom(minMaxVal2_sqSrc)\r\n    },\r\n    /*根据输入的起点dom对象，返回使评估值最小的终点的dom对象*/\r\n    machine_getExactStep(srcDom) {\r\n      let allWays = this.machine_getSteps(srcDom) //该棋子的所有走法,数组元素是dom对象\r\n      /*棋盘中转站*/\r\n      let displayChess_evaluate = this.displayChessTemp.map((item) => {\r\n        //用于评估分数的中转棋盘(不能直接对数组赋值，应对元素赋值)\r\n        return item\r\n      })\r\n      if(!this.playerSide) {\r\n        //如果是黑方执棋\r\n        let maxVal = this.machine_evaluate(this.displayChessTemp)\r\n        let randomDstIndex = Math.floor(Math.random() * allWays.length)\r\n        let dstDom = allWays[randomDstIndex]//初始就赋一个随机值\r\n        // console.log(srcDom);\r\n        for(let i in allWays) {\r\n          let srcNum = displayChess_evaluate[this.domToSq(srcDom)]//起点棋子代表的Num值\r\n          let sqDst = this.domToSq(allWays[i])//终点棋子的一维坐标\r\n          let tempNum = displayChess_evaluate[sqDst]//保存一下落棋前终点处的棋子Num\r\n          /*假设终点落下该棋，即终点处的Num值改变*/\r\n          displayChess_evaluate[sqDst] = srcNum\r\n          let currentVal = this.machine_evaluate(displayChess_evaluate)\r\n          // console.log('评估值：'+ currentVal);\r\n          if(this.machine_evaluate(displayChess_evaluate) > maxVal) {//如果评估值比原来大\r\n            maxVal = this.machine_evaluate(displayChess_evaluate)//更新最大值\r\n            dstDom = this.sqToDom(sqDst)//更新终点\r\n          }\r\n          // else console.log('此次循环没有大的');\r\n          displayChess_evaluate[this.domToSq(srcDom)] = srcNum//恢复中转棋盘\r\n          displayChess_evaluate[sqDst] = tempNum//恢复中转棋盘\r\n        }\r\n        return dstDom\r\n      }\r\n      else {\r\n        let minVal = this.machine_evaluate(this.displayChessTemp)\r\n        let randomDstIndex = Math.floor(Math.random() * allWays.length)\r\n        let dstDom = allWays[randomDstIndex]//初始就赋一个随机值\r\n        // console.log(srcDom);\r\n        for(let i in allWays) {\r\n          let srcNum = displayChess_evaluate[this.domToSq(srcDom)]//起点棋子代表的Num值\r\n          let sqDst = this.domToSq(allWays[i])//终点棋子的一维坐标\r\n          let tempNum = displayChess_evaluate[sqDst]//保存一下落棋前终点处的棋子Num\r\n          /*假设终点落下该棋，即终点处的Num值改变*/\r\n          displayChess_evaluate[sqDst] = srcNum\r\n          let currentVal = this.machine_evaluate(displayChess_evaluate)\r\n          if(this.machine_evaluate(displayChess_evaluate) < minVal) {//如果评估值比原来小\r\n            // console.log('------------');\r\n            minVal = this.machine_evaluate(displayChess_evaluate)//更新最小值\r\n            dstDom = this.sqToDom(sqDst)//更新终点\r\n          }\r\n          displayChess_evaluate[this.domToSq(srcDom)] = srcNum//恢复中转棋盘\r\n          displayChess_evaluate[sqDst] = tempNum//恢复中转棋盘\r\n        }\r\n        return dstDom\r\n      }\r\n      // console.log(dstDom);\r\n      // console.log(allWays);\r\n      // console.log('当前评估值:' + this.machine_evaluate(this.displayChessTemp));\r\n    },\r\n    /*根据输入的整个棋盘数组，返回红方分数-黑方分数的值，记作《评估值》*/\r\n    machine_evaluate(array) {\r\n      let wVal = this.machine_getVal(array,true), bVal = this.machine_getVal(array,false)\r\n      return wVal - bVal\r\n    },\r\n    /*根据输入的整个棋盘数组，返回*/\r\n    machine_getVal(array,isWhite) {\r\n      let val = 0\r\n      for(let i in array) {\r\n        if(isWhite) {//若是红方\r\n          switch (array[i]) {\r\n            case 8: val += 1000;break\r\n            case 9: val += 20;break\r\n            case 10: val += 20;break\r\n            case 11: val += 45;break\r\n            case 12: val += 90;break\r\n            case 13: val += 40;break\r\n            case 14: val += 10;break\r\n            default: val += 0\r\n          }\r\n        }\r\n        else {\r\n          switch (array[i]) {\r\n            case 16: val += 1000;break\r\n            case 17: val += 20;break\r\n            case 18: val += 20;break\r\n            case 19: val += 45;break\r\n            case 20: val += 90;break\r\n            case 21: val += 40;break\r\n            case 22: val += 10;break\r\n            default: val += 0\r\n          }\r\n        }\r\n      }\r\n      return val\r\n    },\r\n    /*该函数会使局面重新绘制，返回1,2,3,0\r\n    * 1：表示触发了兵线刷新\r\n    * 2：替父从军\r\n    * 3：草木皆兵*/\r\n    machine_passiveSkills() {\r\n      /*兵线刷新*/\r\n      return new Promise((resolve,reject) => {\r\n        /*兵线刷新*/\r\n        let advisorSum = 0, isEaten = false\r\n        let currentVal = this.machine_evaluate(this.displayChessTemp), isSkill3 = false\r\n        // console.log(this.machine_getVal(this.displayChessTemp, false));\r\n        for(let i in this.displayChessTemp) {\r\n          if(this.displayChessTemp[i] === 22) {\r\n            advisorSum ++\r\n          }\r\n          /*替父从军*/\r\n          if(this.displayChessTemp[i] & 8 && this.displayChess_Old[i] & 16) {\r\n            //若某处上一步为黑方棋子，下一步为红方棋子，说明黑方棋子被吃掉\r\n            if(Math.floor(Math.random() + 0.3)) { //附加条件：大概30%几率触发替父从军\r\n              isEaten = true\r\n              this.displayChessTemp[i] = this.displayChess_Old[i]\r\n            }\r\n          }\r\n          /*草木皆兵*/\r\n          if(currentVal > 180 || this.machine_getVal(this.displayChessTemp,false) < 1220) {\r\n            //黑方总价值＜1220，大约损失了两车一炮\r\n            isSkill3 = true\r\n            if(this.displayChessTemp[i] === 1) {\r\n              this.displayChessTemp[i] = 22\r\n            }\r\n          }\r\n        }\r\n        if(advisorSum < 3) {\r\n          for(let i = 0,j = 0;i <5;i++,j+=2) {\r\n            let domSq = this.domToSq($(`#pos${27 + j}`))\r\n            // console.log($(`#pos${27 + j}`));\r\n            this.displayChessTemp[domSq] = 22\r\n          }\r\n          document.querySelector('#skill1').play()\r\n          setTimeout(() => {\r\n            this.drawWithSq()\r\n            // let chessInfo = null\r\n            this.chess1Click(null)\r\n            resolve(1)\r\n          },3000)\r\n        }\r\n        /*替父从军*/\r\n        else if(isEaten) {\r\n          document.querySelector('#skill2').play()\r\n          setTimeout(() => {\r\n            this.drawWithSq()\r\n            // let chessInfo = null\r\n            this.chess1Click(null)\r\n            resolve(2)\r\n          },3000)\r\n        }\r\n        /*草木皆兵*/\r\n        else if(isSkill3) {\r\n          document.querySelector('#skill3').play()\r\n          setTimeout(() => {\r\n            this.drawWithSq()\r\n            // let chessInfo = null\r\n            this.chess1Click(null)\r\n            resolve(3)\r\n          },3000)\r\n        }\r\n        else resolve(0)\r\n      })\r\n    },\r\n    /*根据输入的sq（一维坐标），返回棋盘中该棋子的dom对象*/\r\n    sqToDom(sq) {\r\n      let row = this.RANK_Y(sq)\r\n      let imgIndex = sq - 7*row -29 - 1\r\n      // let domTemp =  $('#pos' + imgIndex)\r\n      return $('#pos' + imgIndex)\r\n    },\r\n    /*根据输入的dom对象，返回sq（一维坐标）*/\r\n    domToSq(dom) {\r\n      let imgIndex = parseInt(dom.attr('id').slice(3)) + 1\r\n      return this.imgIndexToSq(imgIndex)\r\n    },\r\n    sureInput() {\r\n      let newFEN = this.userInput\r\n      this.drawWithFEN(newFEN)\r\n    },\r\n    test2() {\r\n      let newFEN = '1n1akabnr/r8/9/9/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR'\r\n      this.drawWithFEN(newFEN)\r\n    },\r\n    btnClick2() {\r\n      document.querySelectorAll('.audioBx li > audio').forEach((e) => {\r\n        e.play()\r\n      })\r\n    },\r\n    chess1Click(info) {\r\n      // console.log(info);\r\n      this.$emit('show', info)\r\n    }\r\n  },\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.input-box {\r\n  background-color: #1a6aa6;\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  border-radius: 8px;\r\n  padding: 0 0 0 15px;\r\n  overflow: hidden;\r\n  height: 5ch;\r\n\r\n\r\n  i::before {\r\n    font-size: 1.5ch;\r\n    color: white;\r\n  }\r\n\r\n  input {\r\n    border: none;\r\n    box-sizing: border-box;\r\n    background: none;\r\n    color: white;\r\n    outline: none;\r\n    margin-left: 5px;\r\n    padding: 5px;\r\n    width: 100%;\r\n  }\r\n\r\n  input::placeholder {\r\n    color: white;\r\n  }\r\n\r\n  div {\r\n    background-color: #e0e1e2;\r\n    cursor: pointer;\r\n    color: #5a5a5a;\r\n    height: 100%;\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 5px 10px;\r\n    width: 20%;\r\n    font-weight: 600;\r\n    justify-content: center;\r\n  }\r\n\r\n  div:hover {\r\n    background-color: #cacbcd;\r\n  }\r\n}\r\n.f1 {\r\n  margin: 0 5px;\r\n  border: none;\r\n  box-sizing: border-box;\r\n  padding: 13px 10px;\r\n  color: white;\r\n  background-color: #1a6aa6;\r\n  border-radius: 10px;\r\n  cursor: pointer;\r\n  font-weight: 600;\r\n}\r\n.f1:hover {\r\n  background-color: #12609b;\r\n}\r\n.chessBoard {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  justify-content: space-between;\r\n  width: 65%;\r\n  padding: 0.2vw;\r\n  border: 2px solid black;\r\n  box-sizing: border-box;\r\n  position: relative;\r\n  margin: auto;\r\n  .myFontBox {\r\n    font-family: 'LiShu',serif;\r\n    position: absolute;\r\n    top: 46%;\r\n    left: 50%;\r\n    display: flex;\r\n    justify-content: space-around;\r\n    width: 100%;\r\n    transform: translateX(-50%);\r\n    font-size: 3vw;\r\n    div {\r\n    }\r\n  }\r\n  .imgBox {\r\n    width: 11.1%;\r\n    box-sizing: border-box;\r\n    padding: 0.2vw;\r\n    //border: 1px solid black;\r\n    background: url(\"../public/img/chess/bc.png\");\r\n    background-size: 100%;\r\n\r\n    img {\r\n      width: 100%;\r\n      cursor: pointer;\r\n\r\n    }\r\n\r\n    :hover {\r\n      transform: scale(1.1);\r\n    }\r\n  }\r\n\r\n  :nth-child(n+37):nth-child(-n+54) {\r\n    //border: none;\r\n    //background: none;\r\n    //background-image: url(\"../public/img/chess/bc-down.png\");\r\n    background-size: 100%;\r\n    background-repeat: no-repeat;\r\n    //margin: 10px 0;\r\n    //padding: 0;\r\n    //display: flex;\r\n    //justify-content: center;\r\n    //align-items: center;\r\n    img {\r\n      //cursor: default;\r\n      //width: 80%;\r\n\r\n    }\r\n  }\r\n  :nth-child(n+37):nth-child(-n+45) {\r\n    margin: -10px 0 10px 0;\r\n    background-image: url('../public/img/chess/bc-up.png');\r\n    background-repeat: no-repeat;\r\n    background-size: 100%;\r\n  }\r\n  :nth-child(n+46):nth-child(-n+54) {\r\n    background-image: url('../public/img/chess/bc-down.png');\r\n    margin: 10px 0 -10px 0;\r\n    background-repeat: no-repeat;\r\n    background-size: 100%;\r\n  }\r\n}\r\n\r\n@font-face {\r\n  font-family: 'LiShu';\r\n  //src: url('YourWebFontName.eot'); /* IE9 Compat Modes */\r\n  //src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\r\n  src: url('../public/css/LiShu/LiShu.woff') format('woff'), /* Modern Browsers */\r\n  url('../public/css/LiShu/LiShu.ttf')  format('truetype'), /* Safari, Android, iOS */\r\n  url(\"../public/css/LiShu/LiShu.svg\")  format('svg'); /* Legacy iOS */\r\n}\r\n</style>"]}]}